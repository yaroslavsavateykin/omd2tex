

\documentclass[12pt]{article} % Дополнительные размеры
\linespread{1.15}
\usepackage{mathtext}

% Шрифты и кодировка
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{lmodern} % Latin Modern (улучшенный Computer Modern)
%\renewcommand{\ttdefault}{lmtt} % Для моноширинного
%\usepackage[T1,T2A]{fontenc}
\usepackage{cmap}
\usepackage{textcomp}
\usepackage[russian]{babel}
\usepackage{extsizes}

%% Fonts
%\defaultfontfeatures{Mapping=tex-text}
%\setmainfont{CMU Serif}
%\setsansfont{CMU Sans Serif}
%\setmonofont{CMU Typewriter Text}

%------------------------------Packages---------------------------------$

\usepackage{geometry}    % Настрока отступов
\usepackage[version = 4]{mhchem}      % Химические формулы черех \ce{}   
\usepackage{chemgreek}

%\usepackage{chemformula}
%\NewCommandCopy{\ce}{\ch}
%\let\ch\relax

\usepackage{xcolor}      % Выделение цветом
\usepackage{tcolorbox}
\usepackage{soul}        % Выделение цветов
\usepackage{pdflscape}   % Для горизонтальной ориентации
\usepackage{cancel}      % Для горизонтальной ориентации
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{graphicx}    % Вставка картинок 
\usepackage{subcaption}    % Вставка картинок 
\counterwithin{subfigure}{figure}
\usepackage{caption}
\captionsetup[figure]{skip=1pt} % Уменьшает отступ (по умолчанию ~10pt)
\captionsetup[subfigure]{skip=1pt} % Уменьшает отступ (по умолчанию ~10pt)
\captionsetup[table]{skip=1pt} % Уменьшает отступ (по умолчанию ~10pt)
\captionsetup[longtblr]{skip=1pt} % Уменьшает отступ (по умолчанию ~10pt)
\renewcommand{\thesubfigure}{Рис \thefigure.\arabic{figure}.} 
\usepackage{floatrow}  % Чтобы подчеркивания нормально вставлялись вне окружения математики
\usepackage{underscore}  % Чтобы подчеркивания нормально вставлялись вне окружения математики
%\usepackage{hyphenat}  % улучшает алгоритм переносов
\usepackage{svg}
%\pagestyle{empty}
\usepackage{collectbox}

\usepackage[backend=biber, style=ieee]{biblatex}
\usepackage[hidelinks]{hyperref}
\usepackage[capitalize]{cleveref}
\crefname{figure}{рис.}{рис.}
\Crefname{figure}{Рис.}{Рис.}
\crefname{subfigure}{рис.}{рис.}
\Crefname{subfigure}{Рис.}{Рис.}
\crefname{equation}{}{}
\Crefname{equation}{}{}
\crefname{longtblr}{табл.}{табл.}
\Crefname{longtblr}{Табл.}{Табл.}
\crefname{table}{табл.}{табл.}
\Crefname{table}{Табл.}{Табл.}
\crefname{section}{раздел}{раздел}
\Crefname{section}{Раздел}{Раздел}
\crefname{subsection}{подраздел}{подраздел}
\Crefname{subsection}{Подраздел}{Подраздел}
\crefname{subsubsection}{пункт}{пункт}
\Crefname{subsubsection}{Пункт}{Пункт}

% Пакет для настройки заголовков
\usepackage{titlesec}
% Настройка стилей заголовков как в стандартном article
\titleformat{\section}
    {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
    {\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
    {\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Настройка отступов для заголовков
\titlespacing*{\section}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
\titlespacing*{\subsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\DeclareFieldFormat{author}{\textit{#1}}
\DeclareFieldFormat{journaltitle}{#1}
\DeclareFieldFormat{title}{#1}
%\DeclareFieldFormat{url}{}
%\DeclareFieldFormat{doi}{}

%\usepackage{hyperref}

\usepackage{indentfirst}

% Чтобы minted сохрагял все там, где нужно
%\usepackage{currfile-abspath}
%\usepackage{ifthen}
%\getabspath{\jobname.log}
%\ifthenelse{\equal{\theabsdir}{\thepwd}}% using ifthen package
%\ifdefstrequal{\theabsdir}{\thepwd}% using etoolbox package
%    {}{\PassOptionsToPackage{outputdir=../created_files}{minted}}

\usepackage{minted} % Выделение кода   

\usepackage{tabularx,ragged2e}
\usepackage{float}

\makeatletter
\newcommand{\keepwithnext}{\@beginparpenalty 10000}
\makeatother

% УСОВЕРШЕНСТВОВАННЫЕ ТАБЛИЦЫ
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\DefTblrTemplate{contfoot-text}{default}{Продолжение на следующей странице}
\DefTblrTemplate{conthead-text}{default}{(Продолжение)}

%\usepackage{fancyvrb}
\usepackage{tocbibind}

% TIKZ

\usepackage{pgfplots}
\DeclareUnicodeCharacter{2212}{−}
\usepgfplotslibrary{groupplots,dateplot}
\usetikzlibrary{patterns,shapes.arrows}
\pgfplotsset{compat=newest}
\usetikzlibrary{shapes.geometric, arrows, positioning}
\tikzstyle{block} = [rectangle, draw, text centered, text width=10.5cm, minimum height=1.5cm, align=center]
\tikzstyle{line} = [draw, -latex']

% Заголовки
%\usepackage{titlesec}

%\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
%\titlespacing*{\section}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
%\titlespacing*{\subsection}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
%\titlespacing*{\subsubsection}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

%-------------------------------Settings--------------------------------%

% Настройки отступов
\geometry{
    a4paper, 
    left=2cm, 
    right=2cm, 
    top=2cm, 
    bottom=2cm
    }

% Настройки нумерации уравнений. 
% Честно, совсем не понимаю, как оно работает, и пусть.
%\numberwithin{equation}{subsubsection}

%\let\oldsection\section% Store \section
%\renewcommand{\section}{% Update \section
%  \renewcommand{\theequation}{\thesection.\arabic{equation}}% Update equation number
%  \oldsection}% Regular \section
%\let\oldsubsection\subsection% Store \subsection
%\renewcommand{\subsection}{% Update \subsection
%  \renewcommand{\theequation}{\thesubsection.\arabic{equation}}% Update equation number
%  \oldsubsection}% Regular \subsubsection 
%\let\oldsubsubsection\subsubsection% Store \subsubsection 
%\renewcommand{\subsubsection}{% Update \subsubsection 
%  \renewcommand{\theequation}{\thesubsubsection.\arabic{equation}}% Update equation number
%  \oldsubsubsection}% Regular \subsubsection 

\tikzset{>=latex}

\newtcolorbox{box1}{
  colframe=black, % Цвет рамки
  colback=white, % Цвет фона
  arc=3pt, % Закругление углов
  boxrule=0.5pt, % Толщина основной линии рамки
  boxsep=5pt, % Отступ внутри блока
  left=10pt, % Отступ слева
  right=10pt, % Отступ справа
  top=5pt, % Отступ сверху
  bottom=5pt, % Отступ снизу
  %before upper={\begin{quote}}, % Начинаем окружение quote
  %after upper={\end{quote}}, % Заканчиваем окружение quote
  enlarge left by=0pt, % Убираем лишний отступ слева
  enlarge right by=0pt, % Убираем лишний отступ справа
  width=\linewidth-60pt, % Ширина коробки равна ширине строки
  before=\vspace{5pt}, % Отступ перед коробкой
  after=\vspace{5pt} % Отступ после коробки
}

\definecolor{mintgreen}{RGB}{220,255,220}

\DeclareUnicodeCharacter{202F}{\,}


\begin{document}

import re
import yaml 
from .equation import Equation
from tools.search import find_file
from .paragraph import Paragraph
from .codeblock import CodeBlock
from .reference import Reference
class MarkdownParser:
    re_heading = re.compile(r'^(#{1,6})\s+(.*)')
    re_equation = re.compile(r'^\$\$(.*?)\$\$')
    re_table_row = re.compile(r'^\|(.+)\|$')
    re_image = re.compile(r'^!\[(.*?)\]\((.*?)\)')
    re_link = re.compile(r'^\[(.*?)\]\((.*?)\)')
    re_comment = re.compile(r'^<!--(.*?)-->$')
    re_footnote = re.compile(r'^\[\^(.+?)\]:\s+(.*)')
    re_codeblock_start = re.compile(r'^```(\w+)?$')
    #re_text_files1 = re.compile(r'!?\[\[([^\[\]#\|\^]+)(?:\|([^\[\]]+))?\]\]')
    re_text_files1 = re.compile(r'!?\[\[([^|\[\]]+?(?:\.(?:md|tex|txt))?)(?:\|([^\[\]]+))?\]\]')
    re_text_files2 = re.compile(r'!?\[([^\[\]]*)\]\(([^)]*?)(?:\.(md|tex|txt))?\)')
    re_reference = re.compile(r'\^([a-zA-Z0-9_-]+)')
    def __init__(self, 
                 filename: str, 
                 settings: dict,
                 depth: int = 0) -> None:
        self.filename = filename
        self.settings = settings
        self.depth = depth
        self.dir_filename = find_file(filename, search_path = settings['dir'])
        self.yaml = None
    def parse(self):
        from .file import File
        non_md_extensions = [
        ".jpg", ".jpeg", ".png", ".svg", ".gif",  # Изображения
        ".docx", ".pdf", ".xlsx", ".pptx",        # Документы
        ".zip", ".tar", ".gz",                    # Архивы
        ".mp3", ".mp4", ".avi", ".mov",           # Медиа
    ]
        with open(self.dir_filename, "r", encoding="utf-8") as f:
            lines = f.read().splitlines()
        i = 0
        in_yaml = False 
        in_code_block = False
        in_equation = False 
        elements = []
        while i < len(lines):
            line = lines[i]
            # Skipping "" 
            if not line.strip():
                i += 1
                continue
            # READING YAML 
            if i == 0 and line.startswith("---"):
                in_yaml = True
                yaml_lines = []
                i += 1 
                continue
            if in_yaml:
                if line.startswith("---"):
                    in_yaml = False
                    if yaml_lines:
                        self.yaml = yaml.safe_load("\n".join(yaml_lines))
                    i+=1 
                    continue
                else:
                    yaml_lines.append(line)
                    i += 1
                    continue
            # Extracting text files
            m = self.re_text_files1.match(line)
            if m:
                if self.depth >= self.settings["max_file_recursion"]:
                    raise RecursionError(f"Maximum file nesting depth ({self.settings["max_file_recursion"]}) exceeded")
                filename, _ = m.groups()
                if any(filename.endswith(ext) for ext in non_md_extensions): 
                    i += 1
                    continue
                if filename.startswith("#^"):
                    i += 1 
                    continue
                elements.append(File(filename + ".md" if not filename.endswith(".md") else filename, 
                                     self.settings, 
                                     parrentfilename=self.filename,
                                     depth = self.depth + 1))
                i += 1
                continue
            n = self.re_text_files2.match(line)
            if n:
                if self.depth >= self.settings["max_file_recursion"]:
                    raise RecursionError(f"Maximum file nesting depth ({self.settings["max_file_recursion"]}) exceeded")
                _, filename  = n.groups()
                if filename.startswith("#^"):
                    i += 1 
                    continue
                if any(filename.endswith(ext) for ext in non_md_extensions): 
                    i += 1
                    continue
                elements.append(File(filename + ".md" if not filename.endswith(".md") else filename, 
                                     self.settings, 
                                     parrentfilename=self.filename,
                                     depth = self.depth + 1))
                i += 1
                continue
            # БЛОКИ КОДА
            if line.startswith("```") and not in_code_block:
                # Начало блока кода
                blocktype = line.strip("```").strip()
                blocklines = []
                in_code_block = True
                i += 1
                continue
            if in_code_block:
                if line.startswith("```"):
                    if blocklines:  # Проверка на пустые блоки
                        elements.append(CodeBlock(blocktype, blocklines, settings=self.settings["codeblocks"]))
                    in_code_block = False
                    i += 1
                    continue
                else:
                    blocklines.append(line)
                    i += 1
                    continue
            # Переделываем ссылки на другие элементы
            m = self.re_reference.match(line)
            if m: 
                elements.append(Reference(m.group()[1:]))
                i += 1 
                continue
            # УРАВНЕНИЯ
            if line.strip().startswith("$$"):
                if not in_equation:
                    equationlines = []
                    in_equation = True
                else:
                    if equationlines:
                        elements.append(Equation("\n".join(equationlines)))
                    in_equation = False
                i += 1
                continue
            if in_equation:
                equationlines.append(line)  
                i += 1
                continue
            # Параграф
            paragraph_lines = [line]
            i += 1
            while i < len(lines) and lines[i].strip():
                paragraph_lines.append(lines[i])
                i += 1
            joined = '\n'.join(l.strip() for l in paragraph_lines)
            elements.append(Paragraph(joined))
        return elements
"""
            if in_code_block:
                if line.strip() == '```':
                    self.elements.append(CodeBlock(code_lang, code_lines))
                    in_code_block = False
                    code_lang = ""
                    code_lines = []
                else:
                    code_lines.append(line)
                i += 1
                continue
            m = self.re_codeblock_start.match(line)
            if m:
                in_code_block = True
                code_lang = m.group(1) or ""
                code_lines = []
                i += 1
                continue
            m = self.re_heading.match(line)
            if m:
                level = len(m.group(1))
                text = m.group(2).strip()
                self.elements.append(Heading(level, text))
                i += 1
                continue
            m = self.re_equation.match(line)
            if m:
                self.elements.append(Equation(m.group(1).strip()))
                i += 1
                continue
            if self.re_table_row.match(line):
                header = [c.strip() for c in line.strip('|').split('|')]
                i += 1
                if i < len(lines):
                    i += 1  # пропускаем разделитель таблицы
                rows = []
                while i < len(lines) and self.re_table_row.match(lines[i]):
                    row = [c.strip() for c in lines[i].strip('|').split('|')]
                    rows.append(row)
                    i += 1
                self.elements.append(Table(header, rows))
                continue
            m = self.re_image.match(line)
            if m:
                alt, path = m.groups()
                self.elements.append(Image(path.strip(), alt.strip()))
                i += 1
                continue
            m = self.re_link.match(line)
            if m:
                text, href = m.groups()
                self.elements.append(Link(text.strip(), href.strip()))
                i += 1
                continue
            m = self.re_comment.match(line)
            if m:
                self.elements.append(Comment(m.group(1).strip()))
                i += 1
                continue
            m = self.re_footnote.match(line)
            if m:
                label, foot_text = m.groups()
                self.elements.append(Footnote(label.strip(), foot_text.strip()))
                i += 1
                continue
            if not line.strip():
                i += 1
                continue
"""

class Equation:
    def __init__(self, 
                 equation: str) -> None:
        self.equation = equation
        self.reference = None 
    def to_latex(self, 
                 settings = {}):
        from .document import GLOBAL_REFERENCE_DICT
        global GLOBAL_REFERENCE_DICT
        if self.reference:
            GLOBAL_REFERENCE_DICT[self.reference] = "eq"
            equation = rf"""
\begin{{equation}}
{self.equation}
\label{{eq:{self.reference}}}
\end{{equation}}
"""     
        else:
            equation = rf"""
\begin{{equation*}}
{self.equation}
\end{{equation*}}
"""     
        return equation

import json
import os
import shutil 
from .preamble import Preamble
from .file import File
GLOBAL_REFERENCE_DICT = {}
class Document():
    def __init__(self, 
                 filename: str, 
                 settings = "default/settings.json", 
                 preamble = "default/preambule.json"):
        self.filename = filename  
        with open(settings, "r") as f: self.settings = json.load(f)
        if self.settings["preamble"]:
            with open(preamble, "r") as f: self.preamble = Preamble(json.load(f))
        else:
            self.preamble = ""
    def to_latex(self):
        if self.preamble:
            preamble = self.preamble.to_latex()
        else:
            preamble = ""
        file = File(self.filename, self.settings).to_latex()
        document = rf"""
{preamble}
\begin{{document}}
{file}
\end{{document}}"""
        return document
    def clean_output_dir(self):
        keep = self.settings["deletesafe_files"] 
        for filename in os.listdir('.'):
            if filename not in keep:
                file_path = os.path.join('.', filename)
                try:
                    if os.path.isfile(file_path):
                        os.unlink(file_path)
                    elif os.path.isdir(file_path):
                        shutil.rmtree(file_path)
                except Exception as e:
                    print(f"Ошибка: {e}")
    def to_latex_file(self, filename: str = "") -> None:
        file = self.to_latex()
        if filename:
            print()
        else:
            filename = self.filename.strip(".md") + ".tex"
        #with open(os.getcwd() + "/" + filename, "w") as f:
        dir = self.settings["output_dir"]
        dir = os.path.expanduser(dir.strip("/") if dir.endswith("/") else dir) 
        with open(dir + "/" + filename, "w") as f:
            f.write(file)
        if self.settings["makefile"]:
            shutil.copy2("default/Makefile", dir)
    def to_latex_porject(self, 
                         filename = "") -> None:
        a = 1

from .markdownparser import MarkdownParser
from tools.attach_reference import attach_reference 
class File:
    def __init__(self, 
                 filename: str, 
                 settings: dict,
                 depth: int = 0,
                 parrentfilename: str = "") -> None:
        self.filename = filename
        self.parrentfilename = parrentfilename
        self.settings = settings
        self.depth = depth
        self.elements = MarkdownParser(filename, settings, depth).parse() 
    def to_latex(self, settings = {}):
        #print(len(self.elements))
        print(self.elements)
        elements = attach_reference(self.elements) 
        #print(len(elements))
        #print(elements)
        text = "\n\n".join([elem.to_latex(self.settings) for elem in elements])
        return text

from objects.document import GLOBAL_REFERENCE_DICT, Document
def main():
    with open("default/current.md", "r") as f: 
        filename = f.read().strip() 
    doc = Document(filename)
    text = doc.to_latex()
    doc.to_latex_file("test.tex")
    doc.clean_output_dir()
    print(text)
if __name__ == "__main__":
    main()
    print(GLOBAL_REFERENCE_DICT)

{
  "max_file_recursion": 5,
  "dir": "~/Vzlet/",
  "preamble": true,
  "makefile": true,
  "output_dir": "~/omd2tex/test/",
  "deletesafe_files": ["Makefile"],
  "headlines":
  {
  },
  "images": 
  {
  },
  "codeblocks":
  {
  }
}

from PIL import Image as PillowImage
from tools.search import find_file
class Image:
    def _get_image_dimensions(self):
        try:
            with PillowImage.open(self.dir) as img:
                return img.width, img.height
        except FileNotFoundError:
            return None, None
    def __init__(self, 
                 filename: str,
                 parrentfilename: str,
                 caption = "",
                 width = None, 
                 height = None,
                 settings = {}) -> None:
        self.filename = filename
        self.parrentfilename = parrentfilename
        self.dir = find_file(filename, 
                             settings = settings["dir"])
        self.caption = caption
        if not width and not height:
            self.width, self.hight = self._get_image_dimensions() 
        self.reference = None
class 

import os
def find_file(filename, search_path=None):
    """
    Ищет файл в текущей директории и её поддиректориях.
    Параметры:
        filename (str): Имя файла для поиска (например "file.txt")
        search_path (str, optional): Стартовая директория. По умолчанию - текущая.
    Возвращает:
        str: Абсолютный путь к файлу если найден, иначе None.
    """
    # Обработка пути поиска
    if search_path is None:
        search_path = os.getcwd()
    else:
        search_path = os.path.expanduser(search_path)
    # Проверка существования директории
    if not os.path.exists(search_path):
        raise FileNotFoundError(f"Directory doesn't exist: {search_path}")
    # Регистронезависимый поиск для Windows/MacOS
    filename_lower = filename.lower()
    for root, dirs, files in os.walk(search_path):
        for f in files:
            if f.lower() == filename_lower:
                return os.path.join(root, f)
    return None  # Явное указание на отсутствие результата
def get_image_dimensions(file_path):
    """Получает ширину и высоту изображения."""
    try:
        with Image.open(file_path) as img:
            return img.width, img.height
    except FileNotFoundError:
        return None

from .paragraph import Paragraph
class CodeBlock:
    def __init__(self, 
                 blocktype: str,
                 blocklines: list,
                 settings = {}) -> None:
        self.blocktype = blocktype
        self.blocklines = blocklines
        if settings:
            self.settings = settings["codeblocks"]
        else:
            self.settings = {}
        self.reference = None
    @staticmethod
    def _minted_python(blocklines: list):
        block = f"""
\\usemintedstyle{{default}}")
\\begin{{minted}}[mathescape, linenos, numbersep=5pt, frame=lines, framesep=2mm, breaklines]{{python}}") 
{"\n".join(blocklines)}
\\end{{minted}}
"""
        return Paragraph(block)    
    def _apply_blocktype(self):
        functions =  {
            "example": lambda content: Paragraph(f"\\begin{{example}}\n{"\n".join(content)}\n\\end{{example}}"),
            "hidden": lambda content: Paragraph(""),
            "text": lambda content: Paragraph("\n".join(content)),
            "python": self._minted_python,
            "c": self._minted_python,
            "cpp": self._minted_python,
            "c++": self._minted_python,
            "java": self._minted_python,
            "bash": self._minted_python
            }
        if self.blocktype in functions: 
            return functions[self.blocktype](self.blocklines)
        else:
            return Paragraph("\n".join(self.blocklines))
    def to_latex(self, 
                 settings = {}):
        return self._apply_blocktype().to_latex()

\end{document}